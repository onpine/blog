[{"title":"GET和POST有什么区别？","url":"/blog/2021/05/16/GET%E5%92%8CPOST%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/","content":"首先最直观的是语义上的区别。\n而后又有这样一些具体的差别:\n\n从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。\n从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。\n从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。\n从幂等性的角度， GET 是幂等的，而 POST 不是。( 幂等 表示执行相同的操作，结果也是相同的)\n从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的POST 请求只发一个 TCP 包)\n\n"},{"title":"HTTPS是什么？具体流程","url":"/blog/2021/05/22/HTTPS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B/","content":"HTTPS 是在 HTTP 和 TCP 之间建立了一个安全层，HTTP 与 TCP 通信的时候，必须先进过一个安全层，对数据包进行加密，然后将加密后的数据包传送给 TCP，相应的 TCP 必须将数据包解密，才能传给上面的 HTTP。\n浏览器传输一个 client_random 和加密方法列表，服务器收到后，传给浏览器一个 server_random、加密方法列表和数字证书（包含了公钥），然后浏览器对数字证书进行合法验证，如果验证通过，则生成一个 pre_random，然后用公钥加密传给服务器，服务器用 client_random、server_random 和pre_random ，使用公钥加密生成 secret，然后之后的传输使用这个 secret 作为秘钥来进行数据的加解密。\n"},{"title":"HTTP中如何处理表单数据的提交？","url":"/blog/2021/05/22/HTTP%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%90%E4%BA%A4%EF%BC%9F/","content":"在 http 中，有两种主要的表单提交的方式，体现在两种不同的 Content-Type 取值:\n\napplication/x-www-form-urlencoded\nmultipart/form-data\n\n由于表单提交一般是 POST 请求，很少考虑 GET ，因此这里我们将默认提交的数据放在请求体中。\napplication/x-www-form-urlencoded对于 application/x-www-form-urlencoded 格式的表单内容，有以下特点:\n\n其中的数据会被编码成以 &amp; 分隔的键值对\n字符以URL编码方式编码。\n\n如：\n// 转换过程: &#123;a: 1, b: 2&#125; -&gt; a=1&amp;b=2 -&gt; 如下(最终形式)&quot;a%3D1%26b%3D2&quot;\n\nmultipart/form-data对于 multipart/form-data 而言:\n\n请求头中的 Content-Type 字段会包含 boundary ，且 boundary 的值有浏览器默认指定。例:Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe 。\n数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如 Content-Type ，在最后的分隔符会加上 – 表示结束。相应的 请求体 是下面这样:Content-Disposition: form-data;name=&quot;data1&quot;;Content-Type: text/plaindata1----WebkitFormBoundaryRRJKeWfHPGrS4LKeContent-Disposition: form-data;name=&quot;data2&quot;;Content-Type: text/plaindata2----WebkitFormBoundaryRRJKeWfHPGrS4LKe--\n\n小结值得一提的是， multipart/form-data 格式最大的特点在于:每一个表单元素都是独立的资源表述。另外，你可能在写业务的过程中，并没有注意到其中还有 boundary 的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。\n而且，在实际的场景中，对于图片等文件的上传，基本采用 multipart/form-data 而不用application/x-www-form-urlencoded ，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。\n"},{"title":"JavaScript继承","url":"/blog/2021/06/10/JavaScript%E7%BB%A7%E6%89%BF/","content":"JavaScript有多种继承模式，总结起来用到的方法有：原型链的传递、构造函数的借用、对象的复制。\n构造函数和原型对象的关系如下：每个构造函数都有一个prototype属性，指向函数的原型对象；原型对象中又有一个constructor属性，重新指向构造函数。而对象实例中有一个原型指针[[prototype]]（在Firefox、Safari和Chrome中，对应属性proto），指向原型对象。\n原型链继承function SuperType()&#123;    this.superproperty = true;&#125;SuperType.prototype.getSuperValue = function()&#123;    return this.superproperty;&#125;function SubType()&#123;    this.subproperty = false;&#125;SubType.prototype = new SuperType(); //原型链继承SubType.prototype.getSubValue =function()&#123;    return this.subproperty;&#125;var instance = new SubType();alert(instance.getSuperValue());//true\n\n\n通过SubType.prototype=new SuperType()，实现了以下三点：\n\nA：重写了SubType的原型，让子类原型和子类构造函数之间断开联系。\nB：子类原型是父类的实例，其原型指针[[prototype]]指向了父类的原型对象，这样子类就可以沿着原型链访问到父类的方法getSuperValue()。\nC：子类原型是父类实例，通过父类构造函数，子类原型继承了父类的属性superproperty。最终，子类继承了父类的方法和属性。\n\n原型链继承的问题：父类的实例属性成了子类的原型属性，如上面的superproperty，会被子类所有实例共享。该属性是基本类型值时没有问题，但如果是引用类型值（比如数组），那么修改实例1的该属性（比如向数组push一个新值），实例2也会跟着改变。也就是说，实例们只有共性，不能保持个性。\n构造函数继承function SuperType(name)&#123;     this.name = name;&#125;function SubType()&#123;    //继承了SuperType，同时还传递了参数     SuperType.call(this,&quot;Nicholas&quot;);    this.age = 29;&#125;var instance = new SubType();alert(instance.name);  //&quot;Nicholas&quot;alert(instance.age);  //29\n\n\n通过SuperType.call(this)，在子类构造函数中调用了父类的构造函数，创建子类实例会执行子类的构造函数（含父类的构造函数），也就完成了继承。当然，子类和父类的原型是没有关系的，子类实例不能访问父类原型对象中的属性和方法。构造函数继承的问题：方法在构造函数中定义，无法实现函数复用。比如父类中有一个方法getName()，则每次创建子类实例的时候，都要创建一个新的getName()，通过instance1.getName() !== instance.getName()就可以验证这一点。这就是说，实例们保持了个性，却不能共享方法。\n组合继承function SuperType(name)&#123;     this.name = name;      this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123;     alert(this.name);&#125;function SubType(name,age)&#123;    //继承属性     SuperType.call(this,name);      //第二次调用SuperTyper()    this.age = age;&#125;//继承方法SubType.prototype = new SuperType(); //第一次调用SuperTyper()SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123;   alert(this.age);&#125;var instance1 = new SubType(&quot;Nicholas&quot;,29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors);  // &quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;instance1.sayName();      //&quot;Nicholas&quot;instance1.sayAge();       //29var instance2 = new SubType(&quot;Greg&quot;,27);alert(instance2.colors);  // &quot;red&quot;,&quot;blue&quot;,&quot;green&quot;instance2.sayName();      //&quot;Greg&quot;instance2.sayAge();       //27\n\n通过借用构造函数来继承属性，原型链来继承方法。结合了两者的优点，让实例们即保持个性，又共享方法。组合继承的问题：两次调用父类的构造函数。第一次(A):SubType.prototype=new SuperType()，子类原型对象取得了父类的实例属性。第二次(B):SuperType.call(this)，创建子类实例时，调用父类构造函数，重写实例属性，屏蔽了原型对象上同名属性。\n原型式继承function object(o)&#123;     function F()&#123;&#125;;    F.prototype = o;     return new F();&#125;var person = &#123;     name:&quot;Nicholas&quot;,     friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]&#125;;var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends);  //&quot;Shelby,Court,Van,Rob,Barbie&quot;\n\n以一个对象为基础，通过object()函数进行浅复制，再将得到的对象实例加以修改。可以看到，这种继承方法是没有父类和子类的，只是通过复制对象来得到副本。ES5有object.create()方法，是object()的规范化，可以传入两个参数：要复制的对象和额外的属性对象（如{name:{value:Greg}}，这种方式会覆盖基础对象上的同名属性）。原型式继承的问题：和原型链继承一样，继承的属性由所有实例共享，改动一个实例的引用类型值时，所有实例都会改变。\n寄生式继承function createAnother(original)&#123;    var clone = object(original);//object()函数创建对象    clone.sayHi = function()&#123;    //增强这个对象        alert(&quot;hi&quot;);    &#125;;    return clone;                //返回这个对象&#125;var person = &#123;    name:&quot;Nicholas&quot;;    friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;];&#125;     //基础对象var anotherPerson = createAnother(person);  //新对象anotherPerson.sayHi();   //&quot;hi&quot;\n\n寄生式和原型式方法相同，都是复制一个基础对象来得到新对象，不同的是它将对象实例的修改放到也放到函数中，将整个过程（创建、增强、返回）封装了起来。\n寄生组合式继承function inheritPrototype(subType,superType)&#123;    var prototype = object(superType.prototype);  //创建对象    prototype.constructor = subType;              //增强对象    subType.prototype = prototype;                //指定对象&#125;function SuperType(name)&#123;     this.name = name;      this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;SuperType.prototype.sayName = function()&#123;     alert(this.name);&#125;function SubType(name,age)&#123;    //继承属性     SuperType.call(this,name);   //只调用一次SuperTyper()    this.age = age;&#125;//继承方法inheritPrototype(SubType,SuperType);SubType.prototype.sayAge = function()&#123;   alert(this.age);&#125;\n\n顾名思义，这种继承模式就是寄生式（复制）+组合式（原型链+构造函数），将几种方法组合起来。解决了组合式继承两次调用父类构造函数的问题。\n参考简书\n"},{"title":"Promise的理解","url":"/blog/2021/06/20/Promise%E7%9A%84%E7%90%86%E8%A7%A3/","content":"一、什么是 Promise?我们都知道，Promise是承诺的意思，承诺它过一段时间会给你一个结果。Promise是一种解决异步编程的方案，相比回调函数和事件更合理和更强大。从语法上讲，promise是一个对象，从它可以获取异步操作的消息;\n二.promise有三种状态: pending初始状态也叫等待状态，fulfilled成功状态, rejected失败状态;状态一旦改变,就不会再变。创造promise实例后，它会立即执行。\n三、Promise的两个特点\nPromise对象的状态不受外界影响\nPromise的状态一旦改变，就不会再变，任何时候都可以得到这个结果，状态不可以逆\n\n四、Promise的三个缺点\n无法取消Promise,—旦新建它就会立即执行，无法中途取消\n如果不设置回调函数，Promise内部抛出的错误;不会反映到外部\n当处于pending （等待）状态时，无法得知目前进展到哪一个阶段，是刚刚开始还是即将完成\n\n"},{"title":"Vue-Router相关","url":"/blog/2021/05/24/Vue-Router%E7%9B%B8%E5%85%B3/","content":"vue-router 有哪些钩子函数？哪些参数？\n全局前置守卫 router.beforeEach\n全局解析守卫 router.beforeResolve\n全局后置钩子 router.afterEach\n路由独享的守卫 beforeEnter\n组件内的守卫 beforeRouteEnter 、 beforeRouteUpdate 、 beforeRouteLeave\n\n参数：有to（去的那个路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由，如果不用就拦截）最常用就这几种\nroute 和 router 的区别是什么？route 是“路由信息对象”，包括 path , params , hash , query , fullPath，matched , name 等路由信息参数。router 是“路由实例对象”，包括了路由的跳转方法( push 、 replace )，钩子函数等。\n怎么定义vue-router的动态路由？怎么获取传过来的动态参数？在router目录下的index.js文件中，对path属性加上/:id。 使用router对象的params.id\n"},{"title":"Vue的生命周期","url":"/blog/2021/05/24/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。\n\n创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有。\n载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。\n更新前/后：当data变化时，会触发beforeUpdate和updated方法。\n销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在\n\n什么是vue生命周期Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。\nvue生命周期的作用是什么它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。\n第一次页面加载会触发哪几个钩子第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子\nDOM 渲染在 哪个周期中就已经完成DOM 渲染在 mounted 中就已经完成了\n简单描述每个周期具体适合哪些场景生命周期钩子的一些使用方法：\n\nbeforecreate : 可以在这加个loading事件，在加载实例时触发\ncreated : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用\nmounted : 挂载元素，获取到DOM节点\nupdated : 如果对数据统一处理，在这里写上相应函数\nbeforeDestroy : 可以做一个确认停止事件的确认框\nnextTick : 更新数据后立即操作dom\n\n"},{"title":"Vue相关面试题","url":"/blog/2021/05/24/Vue%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"Vue 组件间通信有哪些方式?\nprops/$emit\n$emit/$on\nvuex\n$attrs/$listeners\nprovide/inject\n$parent/$children 与 ref\n\nvue 中怎么重置 data?使用Object.assign()，vm.$data可以获取当前状态下的data，vm.$options.data(this)可以获取到组件初始化状态下的data。\nObject.assign(this.$data, this.$options.data(this)) // 注意加this，不然取不到 data()&#123; a: this.methodA &#125; 中的this.methodA。\n\n组件中写 name 选项有什么作用？\n项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤\nDOM 做递归组件时需要调用自身 name\nvue-devtools 调试工具里显示的组见名称是由vue中组件name决定的\n\n"},{"title":"apply、call、bind的区别","url":"/blog/2021/05/14/apply%E3%80%81call%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"Function.prototype.apply()\nMDN：apply() 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数。\n\n\n调用有指定this值和参数的函数，返回的是结果，这点与call相同。\n与call()相比接收的参数是参数数组。\n\nfunc.apply(thisArg, [argsArray])\n\nFunction.prototype.call()\nMDN：call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\n\n调用有指定this值和参数的函数，返回的是结果，这点与apply相同。\n与apply()相比接收的参数是参数列表。\n\nfunction.call(thisArg, arg1, arg2, ...)\nFunction.prototype.bind()\nMDN：bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。\n\n\n返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。这点与apply()、call()不同。function.bind(thisArg[, arg1[, arg2[, ...]]])\n\n"},{"title":"div垂直居中，左右10px，高度始终为宽度一半","url":"/blog/2021/05/15/div%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%8C%E5%B7%A6%E5%8F%B310px%EF%BC%8C%E9%AB%98%E5%BA%A6%E5%A7%8B%E7%BB%88%E4%B8%BA%E5%AE%BD%E5%BA%A6%E4%B8%80%E5%8D%8A/","content":"\n问题描述: 实现一个div垂直居中, 其距离屏幕左右两边各10px, 其高度始终是宽度的50%。同时div中有一个文字A，文字需要水平垂直居中。\n\n\n思路一：利用height:0; padding-bottom: 50%;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    * &#123;      margin: 0;      padding: 0;    &#125;    html,    body &#123;      height: 100%;      width: 100%;    &#125;    .outer_wrapper &#123;      margin: 0 10px;      height: 100%;      /* flex布局让块垂直居中 */      display: flex;      align-items: center;    &#125;    .inner_wrapper &#123;      background: red;      position: relative;      width: 100%;      height: 0;      padding-bottom: 50%;    &#125;    .box &#123;      position: absolute;      width: 100%;      height: 100%;      display: flex;      justify-content: center;      align-items: center;      font-size: 20px;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;outer_wrapper&quot;&gt;    &lt;div class=&quot;inner_wrapper&quot;&gt;      &lt;div class=&quot;box&quot;&gt;A&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n强调两点:padding-bottom究竟是相对于谁的？答案是相对于 父元素的width值 。\n那么对于这个out_wrapper的用意就很好理解了。 CSS呈流式布局，div默认宽度填满，即100%大小，给out_wrapper设置margin: 0 10px;相当于让左右分别减少了10px。\n父元素相对定位，那绝对定位下的子元素宽高若设为百分比，是相对谁而言的？相对于父元素的(content + padding)值, 注意不含border。\n延伸：如果子元素不是绝对定位，那宽高设为百分比是相对于父元素的宽高，标准盒模型下是content, IE盒模型是content+padding+border。\n"},{"title":"forEach中return有效果吗？如何中断forEach循环？","url":"/blog/2021/05/15/forEach%E4%B8%ADreturn%E6%9C%89%E6%95%88%E6%9E%9C%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%ADforEach%E5%BE%AA%E7%8E%AF%EF%BC%9F/","content":"在forEach中用return不会返回，函数会继续执行。\nlet nums = [1, 2, 3];nums.forEach((item, index) =&gt; &#123;  return;//无效&#125;)\n\n中断方法：\n使用try监视代码块，在需要中断的地方抛出异常。\n官方推荐方法（替换方法）：用every和some替代forEach函数。every在碰到return false的时候，中止循环。some在碰到return true的时候，中止循环\n\n"},{"title":"Hello World","url":"/blog/2021/05/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"localStorage和sessionStorage","url":"/blog/2021/05/22/localStorage%E5%92%8CsessionStorage/","content":"localStoragelocalStorage有一点跟Cookie一样，就是针对一个域名，即在同一个域名下，会存储相同的一段localStorage。\n不过它相对Cookie还是有相当多的区别的:\n\n容量。localStorage 的容量上限为5M，相比于 Cookie 的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。\n只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的性能问题和安全问题。\n接口封装。通过 localStorage 暴露在全局，并通过它的 setItem 和 getItem 等方法进行操作，非常方便。\n\n操作方式接下来我们来具体看看如何来操作 localStorage\nlet obj = &#123; name: &quot;sanyuan&quot;, age: 18 &#125;;localStorage.setItem(&quot;name&quot;, &quot;sanyuan&quot;);localStorage.setItem(&quot;info&quot;, JSON.stringify(obj));\n接着进入相同的域名时就能拿到相应的值:\nlet name = localStorage.getItem(&quot;name&quot;);let info = JSON.parse(localStorage.getItem(&quot;info&quot;));\n从这里可以看出， localStorage 其实存储的都是字符串，如果是存储对象需要调用 JSON 的stringify 方法，并且用 JSON.parse 来解析成对象。\n应用场景利用 localStorage 的较大容量和持久特性，可以利用 localStorage 存储一些内容稳定的资源，比如官网的 logo ，存储 Base64 格式的图片资源，因此利用 localStorage。\nsessionStorage特点sessionStorage 以下方面和 localStorage 一致:\n\n容量。容量上限也为 5M。只存在客户端，默认不参与与服务端的通信。\n接口封装。除了 sessionStorage 名字有所变化，存储方式、操作方式均和 localStorage 一样。但 sessionStorage 和 localStorage 有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分 sessionStorage 就不复存在了。\n\n应用场景\n可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。\n可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用 sessionStorage 就再合适不过了。事实上微博就采取了这样的存储方式。\n\nIndexedDBIndexedDB 是运行在浏览器中的 非关系型数据库 , 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。\n接着我们来分析一下 IndexedDB 的一些重要特性，除了拥有数据库本身的特性，比如 支持事务 ， 存储二进制数据 ，还有这样一些特性需要格外注意：\n\n键值对存储。内部采用 对象仓库 存放数据，在这个对象仓库中数据采用键值对的方式来存储。\n异步操作。数据库的读写属于 I/O 操作, 浏览器中对异步 I/O 提供了支持。\n受同源策略限制，即无法访问跨域的数据库。\n\n"},{"title":"typeof和instanceof区别","url":"/blog/2021/05/15/typeof%E5%92%8Cinstanceof%E5%8C%BA%E5%88%AB/","content":"instanceof比typeof判断数据类型更加准确，体现在引用数据类型上\ntypeof判断数据类型对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。  typeof 1 // &#x27;number&#x27;typeof &#x27;1&#x27; // &#x27;string&#x27;typeof undefined // &#x27;undefined&#x27;typeof true // &#x27;boolean&#x27;typeof Symbol() // &#x27;symbol&#x27;\n但对于引用数据类型，除了函数之外，都会显示”object”。  typeof [] // &#x27;object&#x27;typeof &#123;&#125; // &#x27;object&#x27;typeof console.log // &#x27;function&#x27;\n因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true\nconst Person = function() &#123;&#125;const p1 = new Person()p1 instanceof Person // truevar str1 = &#x27;hello world&#x27;str1 instanceof String // falsevar str2 = new String(&#x27;hello world&#x27;)str2 instanceof String // true\n手动实现instanceof核心: 原型链的向上查找。\nfunction myInstanceof (left, right) &#123;  // 基本数据类型直接返回fasle  if(typeof left !== &#x27;object&#x27; || left === null) retuen false;  //getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象  let proto = Object.getPrototypeOf(left);  while(true) &#123;    // 查找到尽头，还没有找到    if(proto == null) return false;    // 找到相同的原型对象    if(proto == right.prototype) return true;    // 再脱一层衣服    proto = Object.getPrototypeOf(proto);  &#125;&#125;"},{"title":"http2.0协议理解","url":"/blog/2021/06/22/http2-0%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3/","content":"http2.0是一种安全高效的下一代http传输协议。安全是因为http2.0建立在https协议的基础上，高效是因为它是通过二进制分帧来进行数据传输。\n什么是http2.0协议？\n对1.x协议语意的完全兼容\n\n2.0协议是在1.x基础上的升级而不是重写，1.x协议的方法，状态及api在2.0协议里是一样的。\n\n性能的大幅提升\n\n2.0协议重点是对终端用户的感知延迟、网络及服务器资源的使用等性能的优化。\nhttp2.0优化内容1. 二进制分帧\n帧(frame)包含部分：类型Type, 长度Length, 标记Flags, 流标识Stream和frame payload有效载荷。消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。流：是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。\n\n在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。\n2. 多路复用在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。\n而http2.0中的多路复用优化了这一性能。多路复用允许同时通过单一的http/2 连接发起多重的请求-响应消息。有了新的分帧机制后，http/2 不再依赖多个TCP连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级，最后再在另一端把它们重新组合起来。\n\n同域名下所有通信都在单个TCP连接上完成。消除了因多个 TCP 连接而带来的延时和内存消耗\n单个连接可以承载任意数量的双向数据流。\n数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。\n\n3. 头部压缩http1.x的头带有大量信息，而且每次都要重复发送。http/2使用encoder来减少需要传输的header大小，通讯双方各自缓存一份头部字段表，既避免了重复header的传输，又减小了需要传输的大小。\n对于相同的数据，不再通过每次请求和响应发送，通信期间几乎不会改变通用键-值对(用户代理、可接受的媒体类型，等等)只需发送一次。如果首部发生了变化，则只需将变化的部分加入到header帧中，改变的部分会加入到头部字段表中，首部表在 http 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。\n需要注意的是，http 2.0关注的是首部压缩，使用的是专门为首部压缩而设计的HPACK算法，而我们常用的gzip等是报文内容（body）的压缩，二者不仅不冲突，且能够一起达到更好的压缩效果。\n\nhttp/2的HPACK算法使用一份索引表来定义常用的http Header，把常用的 http Header 存放在表里，请求的时候便只需要发送在表里的索引位置即可。\n\n4. 请求优先级在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。（高优先级的流都应该优先发送，但又不会绝对的。）\n5. 服务端推送服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。\n\n推送遵循同源策略；\n这种服务端的推送是基于客户端的请求响应来确定的。\n\nhttp2.0性能瓶颈启用http2.0后会给性能带来很大的提升，但同时也会带来新的性能瓶颈。因为现在所有的压力集中在底层一个TCP连接之上，TCP很可能就是下一个性能瓶颈，比如TCP分组的队首阻塞问题，单个TCP packet丢失导致整个连接阻塞，无法逃避，此时所有消息都会受到影响。未来，服务器端针对http 2.0下的TCP配置优化至关重要。\n"},{"title":"vuex","url":"/blog/2021/05/25/vuex/","content":"vuex是什么？怎么使用？哪种功能场景使用它？vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\nvuex有哪几种属性？有五种，分别是 State、 Getter、Mutation 、Action、 Module\nvuex的State特性\nVuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data\nstate里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新\n它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中\n\nvuex的Getter特性\ngetters 可以对State进行计算操作，它就是Store的计算属性\n 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用\n 如果一个状态只在一个组件内使用，是可以不用getters\n\nvuex的Mutation特性Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；Action可以包含任意异步操作。\n"},{"title":"事件循环机制EventLoop","url":"/blog/2021/05/16/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6EventLoop/","content":"事件循环机制从整体上告诉了我们 JavaScript 代码的执行顺序 Event Loop 即事件循环，是指浏览器或Node 的一种解决 javaScript 单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。\n\n宏任务：script/setTimeout/setInterval/setImmediate/ I/O / UI Rendering\n微任务：process.nextTick()/Promise\n\n浏览器环境下 EventLoop 的执行流程\n一开始整段脚本作为第一个宏任务执行\n执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列\n当前宏任务执行完出队，检查微任务队列，如果有则依次执行，直到微任务队列为空\n执行浏览器 UI 线程的渲染工作\n检查是否有Web worker任务，有则执行\n执行队首新的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空\n\nPromise.resolve().then(()=&gt;&#123;  console.log(&#x27;Promise1&#x27;)  setTimeout(()=&gt;&#123;    console.log(&#x27;setTimeout2&#x27;)  &#125;,0)&#125;);setTimeout(()=&gt;&#123;  console.log(&#x27;setTimeout1&#x27;)  Promise.resolve().then(()=&gt;&#123;    console.log(&#x27;Promise2&#x27;)  &#125;)&#125;,0);console.log(&#x27;start&#x27;);// start// Promise1// setTimeout1// Promise2// setTimeout2\nnodejs 和 浏览器关于eventLoop的主要区别两者最主要的区别在于浏览器中的微任务是在 每个相应的宏任务中执行的，而nodejs中的微任务是在不同阶段之间执行的。\n关于process.nextTick的一点说明process.nextTick 是一个独立于 eventLoop 的任务队列。在每一个 eventLoop 阶段完成后会去检查这个队列，如果里面有任务，会让这部分任务优先于微任务执行。\n"},{"title":"事件是如何实现的？","url":"/blog/2021/06/02/%E4%BA%8B%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/","content":"基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。比如点击按钮，这是个事件（Event），而负责处理事件的代码段通常被称为事件处理程序（EventHandler），也就是「启动对话框的显示」这个动作。\n在 Web 端，我们常见的就是 DOM 事件：\n\nDOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。\nDOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件\nDOM3级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件\n\n"},{"title":"事件流向、事件委托","url":"/blog/2021/05/16/%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%90%91%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","content":"事件流事件流是网页元素接收事件的顺序，”DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。 虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;事件冒泡&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div&gt;    &lt;p id=&quot;parEle&quot;&gt;我是父元素 &lt;span id=&quot;sonEle&quot;&gt;我是子元素&lt;/span&gt;&lt;/p&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;  var sonEle = document.getElementById(&#x27;sonEle&#x27;);  var parEle = document.getElementById(&#x27;parEle&#x27;);  parEle.addEventListener(&#x27;click&#x27;, function () &#123;    alert(&#x27;父级 冒泡&#x27;);  &#125;, false);  parEle.addEventListener(&#x27;click&#x27;, function () &#123;    alert(&#x27;父级 捕获&#x27;);  &#125;, true);  sonEle.addEventListener(&#x27;click&#x27;, function () &#123;    alert(&#x27;子级冒泡&#x27;);  &#125;, false);  sonEle.addEventListener(&#x27;click&#x27;, function () &#123;    alert(&#x27;子级捕获&#x27;);  &#125;, true);&lt;/script&gt;\n当容器元素及嵌套元素，即在 捕获阶段 又在 冒泡阶段 调用事件处理程序时：事件按DOM事件流的顺序执行事件处理程序：\n\n父级捕获\n子级冒泡\n子级捕获\n父级冒泡\n\n且当事件处于目标阶段时，事件调用顺序决定于绑定事件的书写顺序，按上面的例子为，先调用冒泡阶段的事件处理程序，再调用捕获阶段的事件处理程序。依次alert出“子集冒泡”，“子集捕获”。\n事件流向\n冒泡：子节点一层层冒泡到根节点\n捕获顺序与冒泡相反\naddEventListener 最后个参数 true 代表捕获反之代表冒泡\n阻止冒泡不停止父节点捕获\n\n事件委托参考定义：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件好处：给重复的节点添加相同操作，减少 dom 交互，提高性能实现思路：给父组件添加事件，通过事件冒泡，排查元素是否为指定元素，并进行系列操作\n"},{"title":"什么是BFC？","url":"/blog/2021/05/15/%E4%BB%80%E4%B9%88%E6%98%AFBFC%EF%BC%9F/","content":"什么是BFC？\nW3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table\u0002cells, 和 table-captions），以及overflow值不为”visiable”的块级盒子，都会为他们的内容创建新的BFC（Block Fromatting Context， 即块级格式上下文）。\n\n触发条件一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可： 下列方式会创建块格式化上下文：\n\n根元素(html)\n浮动元素（元素的 float 不是 none）\n绝对定位元素（元素的 position 为 absolute 或 fixed）\n行内块元素（元素的 display 为 inline-block）\n表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）\n表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）\n匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header\u0002group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或（inline-table）\noverflow 值不为 visible 的块元素 -弹性元素（display为 flex 或 inline-flex元素的直接子元素）\n网格元素（display为 grid 或 inline-grid 元素的直接子元素） 等等。\n\nBFC渲染规则\nBFC垂直方向边距重叠\nBFC的区域不会与浮动元素的box重叠\nBFC是一个独立的容器，外面的元素不会影响里面的元素\n计算BFC高度的时候浮动元素也会参与计算\n\n应用场景\n防止浮动导致父元素高度塌陷\n避免外边距折叠。两个块同一个BFC会造成外边距折叠，但如果对这两个块分别设置BFC，那么边距重叠的问题就不存在了。\n\n"},{"title":"什么是协程？","url":"/blog/2021/05/16/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%9F/","content":"什么是协程？协程是一种比线程更加轻量级的存在，协程处在线程的环境中， 一个线程可以存在多个协程 ，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。\n协程的运作过程那你可能要问了，JS 不是单线程执行的吗，开这么多协程难道可以一起执行吗？答案是：并不能。一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将 JS 线程的控制权转交给 B协程 ，那么现在 B 执行，A 就相当于处于暂停的状态。\nfunction* A() &#123;  console.log(&quot;我是A&quot;);  yield B(); // A停住，在这里转交线程执行权给B  console.log(&quot;结束了&quot;);&#125;function B() &#123;  console.log(&quot;我是B&quot;);  return 100;// 返回，并且将线程执行权还给A&#125;let gen = A();gen.next();gen.next();// 我是A// 我是B// 结束了\n在这个过程中，A 将执行权交给 B，也就是 A 启动 B ，我们也称 A 是 B 的父协程。因此 B 当中最后return 100 其实是将 100 传给了父协程。需要强调的是，对于协程来说，它并不受操作系统的控制，完全由用户自定义切换，因此并没有进程/线程 上下文切换 的开销，这是 高性能 的重要原因。\n"},{"title":"什么是MVVM？","url":"/blog/2021/05/24/%E4%BB%80%E4%B9%88%E6%98%AFMVVM%EF%BC%9F/","content":"MVVM是Model-View-ViewModel的缩写。MVVM是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。\n在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。\nViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。\nmvvm和mvc区别？它和其它框架（jquery）的区别是什么？哪些场景适合？mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。区别：vue数据驱动，通过数据来显示视图层而不是节点操作。场景：数据操作比较多的场景，更加便捷\n"},{"title":"使用display:inline-block会产生什么问题？解决方法？","url":"/blog/2021/05/15/%E4%BD%BF%E7%94%A8display-inline-block%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F/","content":"问题  两个display：inline-block元素放到一起会产生一段空白。\n产生空白的原因元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据CSS中white-space属性的处理方式（默认是normal，合并多余空白），原来HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，空白符占据一定宽度，所以inline-block的元素之间就出现了空隙。\n解决办法\n将子元素标签的结束符和下一个标签的开始符写在同一行或把所有子标签写在同一行&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;left&quot;&gt;  左  &lt;/div&gt;&lt;div class=&quot;right&quot;&gt;  右  &lt;/div&gt;&lt;/div&gt;\n父元素中设置font-size: 0，在子元素上重置正确的font-size.container&#123;  width:800px;  height:200px;  font-size: 0;&#125;\n为子元素设置float:left.left&#123;  float: left;  font-size: 14px;  background: red;  display: inline-block;  width: 100px;  height: 100px;&#125;//right是同理\n\n"},{"title":"双飞翼布局","url":"/blog/2021/05/14/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/","content":"&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;双飞翼布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;center&quot;&gt;      &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;style&gt;  .container &#123;    width: 100%;  &#125;  .container .center &#123;    float: left;    width: 100%;  &#125;  .container .content &#123;    height: 400px;    margin: 0 200px;    background-color: darkcyan;  &#125;  .container .left &#123;    float: left;    width: 200px;    height: 400px;    margin-left: -100%;    background-color: brown;  &#125;  .container .right &#123;    float: left;    width: 200px;    height: 400px;    margin-left: -200px;    background-color: darkgoldenrod;  &#125;&lt;/style&gt;\n"},{"title":"圣杯布局","url":"/blog/2021/05/14/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/","content":"&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;圣杯布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;style&gt;  .container &#123;    box-sizing: border-box;    width: 100%;    padding: 0 200px;  &#125;  .container .center &#123;    float: left;    width: 100%;    height: 400px;    background-color: chocolate;    border: black 2px solid;    box-sizing: border-box;  &#125;  .container .left &#123;    float: left;    width: 200px;    height: 400px;    margin-left: -100%;    position: relative;    right: 200px;    background-color: cadetblue;  &#125;  .container .right &#123;    float: left;    width: 200px;    height: 400px;    margin-left: -200px;    position: relative;    left: 200px;    background-color: brown;  &#125;&lt;/style&gt;\n"},{"title":"如何理解HTTP状态码？","url":"/blog/2021/05/16/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3HTTP%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9F/","content":"RFC 规定 HTTP 的状态码为三位数，被分为五类:\n\n1xx: 表示目前是协议处理的中间状态，还需要后续操作。\n2xx: 表示成功状态。\n3xx: 重定向状态，资源位置发生变动，需要重新请求。\n4xx: 请求报文有误。\n5xx: 服务器端发生错误。\n\n接下来就一一分析这里面具体的状态码。\n1xx101 Switching Protocols。在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101。\n2xx200 OK是见得最多的成功状态码。通常在响应体中放有数据。204 No Content含义与 200 相同，但响应头后没有 body 数据。206 Partial Content顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段 Content-Range 。\n3xx301 Moved Permanently即永久重定向，对应着302 Found，即临时重定向。比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回 301 ，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。而如果只是暂时不可用，那么直接返回 302 即可，和 301 不同的是，浏览器并不会做缓存优化。304 Not Modified: 当协商缓存命中时会返回这个状态码。\n4xx400 Bad Request: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。403 Forbidden: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。404 Not Found: 资源未找到，表示没在服务器上找到相应的资源。405 Method Not Allowed: 请求方法不被服务器端允许。406 Not Acceptable: 资源无法满足客户端的条件。408 Request Timeout: 服务器等待了太长时间。409 Conflict: 多个请求发生了冲突。413 Request Entity Too Large: 请求体的数据过大。414 Request-URI Too Long: 请求行里的 URI 太大。429 Too Many Request: 客户端发送的请求过多。431 Request Header Fields Too Large请求头的字段内容太大。\n5xx500 Internal Server Error: 仅仅告诉你服务器出错了，出了啥错咱也不知道。501 Not Implemented: 表示客户端请求的功能还不支持。502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。503 Service Unavailable: 表示服务器当前很忙，暂时无法响应服务。\n"},{"title":"实现防抖、节流功能","url":"/blog/2021/05/16/%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81%E5%8A%9F%E8%83%BD/","content":"防抖 debounce如果在定时器的时间范围内再次触发，则重新计时。\nconst debounce = function (fn, delay) &#123;  let timer = null  return (...args) =&gt; &#123;    clearTimeout(timer);    timer = setTimerout(() =&gt; &#123;      fn.apply(this, args)    &#125;, delay);  &#125;&#125;\n\n节流 throttle如果在定时器的时间范围内再次触发，则不予理睬，等当前定时器完成，才能启动下一个定时器。\nconst throttle = function (fn, delay) &#123;  let flag = true;  return (...args) =&gt; &#123;    if(!true)&#123;      return;    &#125;    setTimerout(() =&gt; &#123;      fn.apply(this, args);      flag = false;    &#125;, delay)  &#125;&#125;\n"},{"title":"对Cookie了解多少？","url":"/blog/2021/05/17/%E5%AF%B9Cookie%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F/","content":"Cookie 简介HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？\nHTTP 为此引入了 Cookie。Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的Application这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的Set-Cookie 字段来对客户端写入 Cookie 。举例如下:\n// 请求头Cookie: a=xxx;b=xxx// 响应头Set-Cookie: a=xxxset-Cookie: b=xxx\nCookie 属性1. 生存周期Cookie 的有效期可以通过Expires和Max-Age两个属性来设置。\n\nExpires即 过期时间\nMax-Age用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。\n\n若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。\n2. 作用域关于作用域也有两个属性: Domain和path, 给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说， / 表示域名下的任意路径都允许使用 Cookie。\n3. 安全相关如果带上 Secure ，说明只能通过 HTTPS 传输 cookie。\n如果 cookie 字段带上 HttpOnly ，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 跨站脚本攻击(XSS) 攻击的重要手段。\n相应的，对于 跨站请求伪造攻击(CSRF) 攻击的预防，也有 SameSite 属性。SameSite 可以设置为三个值， Strict 、 Lax 和 None。a. 在 Strict 模式下，浏览器完全禁止第三方请求携带Cookie。比如请求 abc.com 网站只能在abc.com 域名当中请求才能携带 Cookie，在其他网站请求都不能。b. 在 Lax 模式，就宽松一点了，但是只能在 get 方法提交表单 况或者 a 标签发送 get 请求 的情况下可以携带 Cookie，其他情况均不能。c. 在 None 模式下，也就是默认模式，请求会自动携带上 Cookie。\nCookie 的缺点1. 容量缺陷。Cookie 的体积上限只有 4KB ，只能用来存储少量的信息。2. 性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过 Domain 和 Path 指定作用域来解决。3. 安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly 为false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。\n"},{"title":"对重绘和回流的理解","url":"/blog/2021/05/22/%E5%AF%B9%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3/","content":"渲染流水线的流程:\n回流首先介绍回流。回流也叫重排。\n触发条件简单来说，就是当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生 回流 的过程。具体一点，有以下的操作会触发回流:\n\n一个 DOM 元素的几何属性变化，常见的几何属性有 width 、 height 、 padding 、 margin 、left 、 top 、 border 等等, 这个很好理解。\n使 DOM 节点发生 增减 或者 移动 。\n读写 offset 族、 scroll 族和 client 族属性的时候，浏览器为了获取这些值，需要进行回流操作。\n调用 window.getComputedStyle 方法。回流过程依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。相当于将解析和合成的过程重新又走了一篇，开销是非常大的。\n\n重绘触发条件当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致 重绘 ( repaint )。\n重绘过程由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。流程如下：跳过了 生成布局树 和 建图层树 的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。\n可以看到，重绘不一定导致回流，但回流一定发生了重绘。\n"},{"title":"简要概括一下HTTP的特点？HTTP有哪些缺点？","url":"/blog/2021/05/16/%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC%E4%B8%80%E4%B8%8BHTTP%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9FHTTP%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BC%BA%E7%82%B9%EF%BC%9F/","content":"HTTP 特点HTTP 的特点概括如下:\n\n灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。\n可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。\n请求-应答。也就是 一发一收 、 有来有回 ， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。\n无状态。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。\n\nHTTP 缺点\n无状态所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是http 的缺点了。但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。\n明文传输即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI陷阱 就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。\n队头阻塞问题当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。\n\n"},{"title":"能不能写一个完整的深拷贝？","url":"/blog/2021/05/15/%E8%83%BD%E4%B8%8D%E8%83%BD%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F/","content":"简易版及问题JSON.parse(JSON.stringify());\n这个api能覆盖大多数的应用场景,但是实际上，对于某些严格的场景来说，这个方法是有巨大的坑的。问题如下：\n\n无法解决 循环引用 的问题。举个例子：const a = &#123;val:2&#125;;a.target = a\n拷贝a会出现系统栈溢出，因为出现了 无限递归 的情况。\n无法拷贝一写 特殊的对象 ，诸如 RegExp, Date, Set, Map等。\n无法拷贝 函数 (划重点)。\n\n深拷贝手写2（解决循环引用）const isObject = (target) =&gt; (typeof target === &#x27;object&#x27; || typeof target === &#x27;function&#x27;) &amp;&amp; target !== null;const deepClone = (target, map = new WeakMap()) =&gt; &#123;  // 创建一个Map。记录下已经拷贝过的对象，如果说已经拷贝过，那直接返回它行了。  if(map.get(target))    return target;  if (isObject(target)) &#123;    map.set(target, true);    const cloneTarget = Array.isArray(target) ? []: &#123;&#125;;    for (let prop in target) &#123;      if (target.hasOwnProperty(prop)) &#123;        cloneTarget[prop] = deepClone(target[prop],map);      &#125;    &#125;    return cloneTarget;  &#125; else &#123;  return target;  &#125;&#125;\n\n拷贝特殊对象（可拷贝对象、不可拷贝对象）…\n拷贝函数…\n"},{"title":"让一个元素水平垂直居中，到底有多少种方案？","url":"/blog/2021/05/15/%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%8C%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E6%A1%88%EF%BC%9F/","content":"水平居中\n对于 行内元素 : text-align: center;\n对于确定宽度的块级元素：\nwidth和margin实现。margin: 0 auto;\n绝对定位和margin-left: -width/2, 前提是父元素position: relative\n\n\n对于宽度未知的块级元素\ntable标签配合margin左右auto实现水平居中。使用table标签（或直接将块级元素设值为display:table），再通过给该标签添加左右margin为auto。\ninline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。\n绝对定位+transform，translateX可以移动本身元素的50%。\nflex布局使用justify-content:center垂直居中\n\n\n\n\n利用 line-height 实现居中，这种方法适合纯文字类\n通过设置父容器 相对定位 ，子级设置 绝对定位 ，标签通过top、bottom、left、right、margin实现自适应居中\n弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中\n父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现\ntable 布局，父级通过转换成表格形式，然后子级设置 vertical-align 实现。（需要注意的是：vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）。\n\n"}]